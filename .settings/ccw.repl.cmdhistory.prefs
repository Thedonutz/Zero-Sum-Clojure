cmdhistory=["(min (first( rest x)), (first(rest(reverse x))), (first(rest(rest x))), (first(reverse x)))" "(defn choice [x]\\n  (+ (first x) (min (first( rest x)), (first(rest(reverse x))), \\n                    (first(rest(rest x))), (first(reverse x)))))" "(choice '(1 2 3 4 5))" "(choice '(1 2 3 4 5 6 7))" "(defn choice [x]\\n  (+ (first x) (min (first( rest x)), (first(rest(reverse x))), \\n                    (first(rest(rest x))), (first(reverse x)))))" "(choice '(1 2 3 4 5 6 7))" "(choice '(getWorkingList))" "(choice (getWorkingList))" "x" "(def z 55)" "z" "(def z '( 1 2 3 4 5))" "z" "(last z)" "(choice (getWorkingList))" "(choice (getWorkingReverseList))" "x" "(def x '(1 2 3 4 5))" "x" "(+ (first x) (first x))" "(last (last x))" "(last x)" "(last (butlast x))" "(last (butlast (butlast x)))" "(defn altChoice [x]\\n  (+ (last x) (min (first x), (last (butlast (butlast x)), \\n                                    (first (rest x)), (last (butlast x))))))" "(altChoice (getWorkingList))" "(defn altChoice [x]\\n  (+ (last x) (min (first x), (last (butlast (butlast x))), \\n                                    (first (rest x)), (last (butlast x)))))" "(altChoice (getWorkingList))" "(mainAlg (getWorkingList))" "(def x '(1 2))" "(choice x)" "(choice (x))" "(def y '(1 2 3 4 5))" "(choice y)" "(def y '(1 2 3 4))" "(choice y)" "(def y ('1 2 3))" "(def y '(1 2 3))" "(choice y)" "(def y '(1 2))" "(choice y)" "(def y '(1 2 3))" "(def x '(1 2))" "(mainAlg y)" "(defn mainAlg [x]\\n  (if (>\= count '(x)\\n          ) (max (first x), (last x)) (max (choice x) (altChoice x))))" "(mainAlg y)" "(def y '(1 2 3))" "(def x '(1 2))" "(mainAlg y)" "(mainAlg x)" "(mainAlg (getWorkingList))" "(choice (getWorkingList))" "(mainAlg (getWorkingList))" "(def y '(1 2 3))" "(mainAlg y)" "(mainAlg (getWorkingList))" "(choice (getWorkingList))" "(altChoice (getWorkingList))" "(defn mainAlg [x]\\n  (cond\\n    (>\= (count (x)) 2) (max (first x), (last x)) \\n    true (max (choice x) (altChoice x))))" "(mainAlg (getWorkingList))" "(defn mainAlg [x]\\n  (cond\\n    (>\= (count 'x\\n               ) 2) (max (first x), (last x)) \\n    true (max (choice x) (altChoice x))))" "(mainAlg (getWorkingList))" "(def size 6)" "size" "(\= (mod (size 2) 0))" "(mod (size 2) 0)" "(mod size 2)" "(mainProg (getWorkingList))" "(listReturned (getWorkingList))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [player1 0 player2 0]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned x) (swap\! player1 + (mainAlg x)))\\n    (\= (mod size 2) 1)    (recur (listReturned x) (swap\! player2 + (mainAlg x)))\\n    true (recur (listReturned x) (dec size))))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [player1 (atom 0) player2 (atom 0)]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned x) (swap\! player1 + (mainAlg x)))\\n    (\= (mod size 2) 1)    (recur (listReturned x) (swap\! player2 + (mainAlg x)))\\n    true (recur (listReturned x) (dec size))))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n  (let [size (getSize), player1 0, player2 0]\\n(loop [x, player1, player2, size]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned x), (+ player1 (mainAlg x)), player2, (dec size))\\n    (\= (mod size 2) 1)    (recur (listReturned x), player1, (+ player2 (mainAlg x)), (dec size))\\n    true (recur (listReturned x), player1, player2, (dec size))))))" "(defn mainProg [x]\\n  (let [size (getSize), player1 0, player2 0]\\n(loop [player1, player2]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned x), (+ player1 (mainAlg x)), player2, (dec size))\\n    (\= (mod size 2) 1)    (recur (listReturned x), player1, (+ player2 (mainAlg x)), (dec size))\\n    true (recur (listReturned x), player1, player2, (dec size))))))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [player1 0, player2 0]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned x) (+ player1 (mainAlg x)) player2 (dec size))\\n    (\= (mod size 2) 1)    (recur (listReturned x) player1 (+ player2 (mainAlg x)) (dec size))\\n    true (recur (listReturned x), player1, player2, (dec size))))))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [player1, player2]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned x) (+ player1 (mainAlg x)) player2 (dec size))\\n    (\= (mod size 2) 1)    (recur (listReturned x) player1 (+ player2 (mainAlg x)) (dec size))\\n    true (recur (listReturned x), player1, player2, (dec size))))))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [l x , player1 0,  player2 0, s size]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned l) (+ player1 (mainAlg x)) player2 (dec s))\\n    (\= (mod size 2) 1)    (recur (listReturned l) player1 (+ player2 (mainAlg x)) (dec s))\\n    true (recur (listReturned l), player1, player2, (dec s))))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [ x , player1 0,  player2 0, size]\\n  (cond\\n    (\= size 0) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod size 2) 0)    (recur (listReturned l) (+ player1 (mainAlg x)) player2 (dec s))\\n    (\= (mod size 2) 1)    (recur (listReturned l) player1 (+ player2 (mainAlg x)) (dec s))\\n    true (recur (listReturned l), player1, player2, (dec s))))))" "(mainProg (getWorkingList))" "(\= (mod 2 2) 0)" "(\= 3 0)" "(def size 3)" "(\= (mod size) 0)" "(\= (mod size 2) 0)" "(\= (mod (or size) 2) 0)" "(mainProg (getWorkingList))" "(+ player1 (mainAlg (getWorkingList)))" "(def size (getSize))" "(dec size)" "(println \\"player1 has\\" size)" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [l x, play1 player1, play2 player2 ,s size]\\n  (cond\\n    (<\= (or size) 1) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod (or size) 2) 0)    (recur (listReturned l) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or size) 2) 1)    (recur (listReturned l) play1 (+ play2 (mainAlg x)) (dec s))\\n    true (recur (listReturned l), play1, play2, (dec s))))))" "(mainProg '(1 2 3 4))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [l x, play1 player1, play2 player2 ,s size]\\n  (cond\\n    (<\= (or size) 1) (println \\"Player1 has \\" player1, \\"Player2 has \\" player2)\\n    (\= (mod (or size) 2) 0)    (recur (listReturned l) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or size) 2) 1)    (recur (listReturned l) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned l), play1, play2, (dec s))))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n  (let [size (getSize)]\\n(loop [l x, play1 0, play2 0 ,s size]\\n  (cond\\n    (<\= (or size) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or size) 2) 0)    (recur (listReturned l) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or size) 2) 1)    (recur (listReturned l) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned l), play1, play2, (dec s))))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [l x, play1 0, play2 0 ,s size]\\n  (let [s (getSize)]\\n  (cond\\n    (<\= (or size) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or size) 2) 0)    (recur (listReturned l) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or size) 2) 1)    (recur (listReturned l) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned l), play1, play2, (dec s))))))" "(defn mainProg [x]\\n(loop [l x, play1 0, play2 0 ,s 0]\\n  (let [s (getSize)]\\n  (cond\\n    (<\= (or size) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or size) 2) 0)    (recur (listReturned l) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or size) 2) 1)    (recur (listReturned l) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned l), play1, play2, (dec s))))))" "(mainProg (getWorkingList))" "(mainProg (getWorkingList) size)" "(defn mainProg [x y]\\n(loop [l x, play1 0, play2 0 ,s y]\\n  (cond\\n    (<\= (or s) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or s) 2) 0)    (recur (listReturned l) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or s) 2) 1)    (recur (listReturned l) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned l), play1, play2, (dec s)))))" "(mainProg (getWorkingList) size)" "(defn testing [x]\\n  (loop [x]\\n    (cond\\n      (> x 1) (recur (dec x))\\n      \:else (println \\"done\\"))))" "(defn testing [xs]\\n  (loop [xs x]\\n    (cond\\n      (> x 1) (recur (dec x))\\n      \:else (println \\"done\\"))))" "(defn testing [y]\\n  (loop [y]\\n    (cond\\n      (> y 1) (recur (dec y))\\n      \:else (println \\"done\\"))))" "(defn testing [y]\\n  (loop [y t]\\n    (cond\\n      (> t 1) (recur (dec t))\\n      \:else (println \\"done\\"))))" "(defn testing [y]\\n  (loop [y]\\n    (cond\\n      (> y 1) (recur (dec y))\\n      \:else (println \\"done\\"))))" "(defn testing [y]\\n  (loop [x y]\\n    (cond\\n      (> y 1) (recur (dec y))\\n      \:else (println \\"done\\"))))" "(testing 10)" "(defn mainProg [x]\\n(loop [list x, play1 0, play2 0 ,s size]\\n  (cond\\n    (<\= (or s) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or s) 2) 0)    (recur (listReturned l) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or s) 2) 1)    (recur (listReturned l) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned l), play1, play2, (dec s)))))" "(defn mainProg [x]\\n(loop [list x, play1 0, play2 0 ,s size]\\n  (cond\\n    (<\= (or s) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or s) 2) 0)    (recur (listReturned list) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or s) 2) 1)    (recur (listReturned list) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned list), play1, play2, (dec s)))))" "(mainProg (getWorkingList))" "(listReturned (getWorkingList))" "(mainAlg (getWorkingList))" "(defn mainProg [x p1 p2 size]\\n  (cond\\n    (<\= (or s) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or s) 2) 0)    (recur (listReturned a) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or s) 2) 1)    (recur (listReturned a) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned a), play1, play2, (dec s))))" "(defn mainProg [x play1 play2 s]\\n  (cond\\n    (<\= (or s) 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod (or s) 2) 0)    (recur (listReturned x) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod (or s) 2) 1)    (recur (listReturned x) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned x), play1, play2, (dec s))))" "(mainProg (getWorkingList) p1 p2 size)" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [a x, play1 p1, play2 p2 ,s size]\\n  (cond\\n    (<\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod s 2) 1)    (recur (listReturned a) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned a), play1, play2, (dec s)))))" "(mainProg (getWorkingList))" "(mainProg (1 2 3 4 5 6))" "(mainProg '(1 2 3 4 5))" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (<\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod s 2) 1)    (recur (listReturned a) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned a), play1, play2, (dec s)))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (>\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod s 2) 1)    (recur (listReturned a) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned a), play1, play2, (dec s)))))" "(mainProg (getWorkingList))" "(\= (mod 10 2) 0)" "(def s 5)" "(>\= 1 s)" "(>\= s 5)" "(>\= s 3)" "(>\= s 6)" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (>\= s 1) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod s 2) 1)    (recur (listReturned a) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned a), play1, play2, (dec s)))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (>\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod s 2) 1)    (recur (listReturned a) play1 (+ play2 (mainAlg x)) (dec s))\\n    \:else (recur (listReturned a), play1, play2, (dec s)))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (>\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ play1 (mainAlg x)) play2 (dec s))\\n    (\= (mod s 2) 1)    (recur (listReturned a) play1 (+ play2 (mainAlg x)) (dec s)))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (>\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a), (+ play1 (mainAlg x)), play2, (dec s))\\n    (\= (mod s 2) 1)    (recur (listReturned a), play1, (+ play2 (mainAlg x)), (dec s))\\n    \:else (recur (listReturned a), play1, play2, (dec s)))))" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (>\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a), (+ play1 (mainAlg x)), play2, (dec s))\\n    \:else    (recur (listReturned a), play1, (+ play2 (mainAlg x)), (dec s)))))" "(mainProg (getWorkingList))" "s" "size" "(dec size)" "(+ p1 (mainalg (getWorkingList)))" "(+ p1 (mainAlg (getWorkingList)))" "(defn mainProg [x]\\n(loop [a x, play1 0, play2 0 ,s size]\\n  (cond\\n    (>\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a), (+ play1 (mainAlg x)), play2, (dec s))\\n    \:else    (recur (listReturned a), play1, (+ play2 (mainAlg x)), (dec s)))))" "(mainProg (getWorkingList))" "(defn mainProg [x y w z]\\n(loop [a x, play1 y, play2 w ,s z]\\n  (cond\\n    (>\= 1 s) (println \\"Player1 has \\" play1, \\"Player2 has \\" play2)\\n    (\= (mod s 2) 0)    (recur (listReturned a), (+ play1 (mainAlg x)), play2, (dec s))\\n    \:else    (recur (listReturned a), play1, (+ play2 (mainAlg x)), (dec s)))))" "(mainProg (getworkingList) p1 p2 (getSize))" "(mainProg (getW\\n            orkingList) p1 p2 (getSize))" "(mainProg (getWorkingList) p1 p2 (getSize))" "(mainProg (getWorkingList) p1 p2 size)" "p1" "size" "p2" "(getWorkingList)" "'(getWorkingList)" "(\= (mod s 2) 0)" "(def s 4)" "(\= (mod s 2) 0)" "(\= (mod s 2) 1)" "(mainProg (getWorkingList))" "(defn mainProg [x]\\n(loop [a x, p pone, q ptwo ,s size]\\n  (cond\\n    (>\= 2 s) (println \\"Player1 has \\" p, \\"Player2 has \\" q)\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ p (mainAlg x)) q (dec s))\\n    \:else    (recur (listReturned a) p (+ q (mainAlg x)) (dec s)))))" "(mainProg (getWorkingList))" "(def s 2)" "(\= 2 s)" "(and (\= 2 s) (\= 0 s)\\n     )" "(and (<\= 2 s) (not 0))" "s" "(and true true)" "s" "(and (>\= 2 s) (not 0))" "(and (<\= 2 s) (not\= 0))" "s" "(<\= 2 s)" "(and (<\= 2 s) (not\= s 0\\n                    ))" "(defn mainProg [x]\\n(loop [a x, p pone, q ptwo ,s size]\\n  (cond\\n    (\= 0 s) (println \\"Player1 has \\" p, \\"Player2 has \\" q)\\n    (and (<\= 2 s) (not\= s 0)) (recur a (+ (max (first a), (last a)) p) (+ (min (first a), (last a)) q)\\n                                     (dec (dec s)))\\n    (\= (mod s 2) 0)    (recur (listReturned a) (+ p (mainAlg x)) q (dec s))\\n    \:else    (recur (listReturned a) p (+ q (mainAlg x)) (dec s)))))" "(mainProg (getWorkingList))" "(def s 0)" "(and (<\= 2 s) (not\= s 0))" "(and (<\= 2 s) (not\= 0 s\\n                    ))" "(def s 2)" "(and (<\= 2 s) (not\= s 0))" "(def s 1)" "(and (<\= 2 s) (not\= s 0))" "(and (<\= s 2) (not\= s 0))" "s" "(mainProg (getWorkingList))" "(getWorkingList)" "(mainProg (getWorkingList))" "(def s 3)" "(\= (mod s 2) 0)" "(\= (mod s 2) 1)" "(mainProg (getWorkingList))" "(choice (getWorkingList))" "(choice (convertedList))" "(altChoice (convertedList))" "(mainProg (convertedList))" "(time (mainProg (convertedList)))" "(time (doall (pmap mainProg (convertedList) (range 32))" "(pmap (mainProg (convertedList)))" "(doc pmap)" "(pmap convertedList)" "(pmap (convertedList))" "(pmap (convertedList) 4)" "(time (mainProg (convertedList)))" "(pmap)" "(pmap [1 2 3])" "(pmap inc[1 2 3])" "(para)" "(pmap mainAlg(convertedList))" "(para)" "(defn para []\\n  (doall (pmap mainAlg (convertedList) (range 4))))" "(para)" "(doall (pmap (choice (convertedList))))" "(doall (pmap choice (convertedList)))" "(para)" "(mainProg (convertedList))" "(pmap (mainProg (splitter 16(convertedList))))" "(mainProg (pmap splitter 16(convertedList)))" "(pmap mainProg(splitter 2 (convertedList)))" "(pmap mainProg(splitter 4(convertedList)))" "(pmap mainProg(splitter 2 (read-lines\\n                            )))" "(mainProg(splitter 2(convertedList)))" "(mainProg(pmap splitter 2(convertedList)))" "(splitter 2(convertedList))" "(splitter 2(read-lines))" "(doall (pmap mainProg(convertedList)))" "(doall (pmap mainProg(splitter 2(convertedList))))" "(splitter 2(convertedList))" "(splitter 4(convertedList))" "(splitter 16(convertedList))" "(splitter 4(read-lines))" "(defn half-split[coll] (split-at (/ (count coll) 2) coll))" "(half-split (convertedList))" "(pmap mainProg(half-split (convertedList)))" "(doall (pmap mainProg(half-split(convertedList))))" "(doall(mainProg(half-split(convertedList))))" "(defn split-shuffled [c p] (split-at (* p (count c)) (shuffle c)))" "(split-shuffled (convertedList))" "(split-shuffled (convertedList) 2)" "(split-shuffled(convertedList 2))" "(split-shuffled(convertedList) 4)" "(choice (convertedList))" "(choice(convertedList))" "(choice (convertedList))" "(defn choice [x]\\n  (cond\\n    ;;(<\= (count x) 2) (max (first x), (last x)) \\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(choice (convertedList))" "(defn choice [x]\\n (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n      (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))" "(choice (convertedList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(choice (convertedList))" "(choice(convertedList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    (> (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n         (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))) (first x)\\n    \:else (last x)))" "(choice (convertedList))" "(rest (convertedList))" "(first (convertedList))" "(mainProg (convertedList))" "(listMath (convertedList))" "(reduce + (convertedList))" "(reduct + (rest (convertedList)))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    (> (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n         (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    (> (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n         (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))\\n  \:else true))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n         (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n         (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))) (max)))" "(choice (convertedList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n         (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))) (x)))" "(choice (convertedList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    (> (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n         (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))) (first x)\\n    \:else (last x)))" "(choice (convertedList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(choice (convertedList))" "\\n(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) 0\\n    \:else (max (+ (first x) (min (recur (rest (butlast x))),  (recur(rest(rest x))))),\\n               (+ (last x) (min (recur (butlast( butlast x))), (recur(rest (butlast x))))))))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(choice (convertedList))" "(choice (workingList))" "(defn workingList []\\n  (rest (convertedList)))" "(choice (workingList))" "(defn opponent [x]\\n  (reduce + x))" "(opponent (workingList))" "(score (workingList))" "(defn player1 [x]\\n  (choice x))" "(score (workingList))" "(defn score [x]\\n  (let [player1 (player1 x)]\\n  (println \\"Player 1 will receive\\" player1 \\"Player 2 gets\\" (- (reduce + x) (player1)))))" "(score (workingList))" "(defn score [x]\\n  (let [player1 (player1 x)]\\n  (println \\"Player 1 will receive\\" player1 \\"Player 2 gets\\" (- (reduce + x) player1))))" "(score (workingList))" "(threadTest)" "(time)" "x" "3" "(time (doall (score (workingList))))" "(defn choice [y]\\n  (loop [x y]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (recur (rest (butlast x))),  (recur(rest(rest x))))),\\n               (+ (last x) (min (recur (butlast( butlast x))), (recur(rest (butlast x)))))))))" "(defn choice [y]\\n  (loop [x y]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (recur (max (+ (first x) (min (rest (butlast x))),  (rest(rest x))))),\\n               (+ (last x) (min  (butlast( butlast x))), (rest (butlast x))))))" "(defn choice [y]\\n  (loop [x y]\\n  (if (<\= (count x) 2) (max (first x), (last x)) (recur (max (+ (first x) (min (rest (butlast x))),  (rest(rest x))))),\\n               (+ (last x) (min  (butlast( butlast x))), (rest (butlast x))))))" "(defn choice [y]\\n  (loop [x y]\\n  (if (<\= (count x) 2) (max (first x), (last x)) (recur (max (+ (first x) (min (rest (butlast x)),  (rest(rest x)))),\\n               (+ (last x) (min  (butlast( butlast x)), (rest (butlast x)))))))))" "(choice (convertedList))" "(choice (read-lines))" "(type (convertedList))" "(type (choice x))" "(type choice)" "(choice (convertedList))" "(choice (read-lines))" "\\n(defn choice [y]\\n  (loop [x y]\\n  (if (<\= (count x) 2) (max (first x), (last x)) (max (+ (first x) (min (recur(rest (butlast x)))),  (recur(rest(rest x)))),\\n               (+ (last x) (min  (recur(butlast( butlast x))), (recur(rest (butlast x)))))))))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(choice (convertedList))" "(score (convertedList))" "(score (workingList))" "(threadTest)" "(score (workingList))" "(defn splitter [splitBy numbers]\\n\\t(partition (/ (count numbers) splitBy) numbers))" "(splitter 2 (convertedList))" "(splitter 2 (read-lines))" "(splitter 2 (into [] (convertedList)))" "(splitter 4 (into [] '(convertedList)))" "(time (doall (pmap (score (workingList)))))" "(time (doall (pmap score (workingList))))" "(-> (score (workingList)))" "(threads)" "(threadTest)" "(defn threadTest []\\n(let [tasks (score (workingList))\\n             futures (invokeAll pool tasks)]\\n         (for [ftr futures]\\n           (get ftr))))" "(defn threadTest []\\n(let [tasks (score (workingList))\\n             futures (.invokeAll pool tasks)]\\n         (for [ftr futures]\\n           (.get ftr))))" "(-> (doall (score(workingList))))" "(time (-> (doall (score(workingList)))))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (choice (min (rest (butlast x)),  (rest(rest x)))),\\n               (+ (last x) (choice (min (butlast( butlast x)), (rest (butlast x)))))))))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (choice (min (rest (butlast x)),  (rest(rest x))))),\\n               (+ (last x) (choice (min (butlast( butlast x)), (rest (butlast x))))))))" "(choice (workingList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(splitter 4 (workingList))" "(map \#(Integer/parseInt %) (read-lines))" "(read-lines)" "(read-string (read-lines))" "(let [input (read-lines)]\\n        (for [line (line-seq (java.io.BufferedReader.\\n                              (java.io.StringReader. input)))]\\n             (vec (map read-string (re-seq \#\\"[\\\\d.]+\\" line)))))" "(work)" "(score (workingList))" "(fn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(defn get-lines [file]\\r\\n  (map read-string \\r\\n       (str/split-lines\\r\\n         (slurp file)\\r\\n         )\\r\\n       )\\r\\n  )" "(get-lines \\"10.txt\\")" "(get-lines \\"resources/10.txt\\")" "(readlines)" "(read-lines)" "(convertedList)" "(choice (workingList))" "10.txt" "(pmap inc(convertedList))" "(pmap choice(convertedList))" "(defn choice [list x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(pmap choice(convertedList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (pmap (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n                     (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(choice (convertedList))" "(pmap max(convertedList))" "\\n(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (pmap max(+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n                     (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(choice (convertedList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (future (choice (rest (butlast x)))),  (future (choice(rest(rest x)))))),\\n               (+ (last x) (min (future (choice (butlast( butlast x)))), (future (choice(rest (butlast x)))))))))" "(choice (workingList))" "(choice @(workingList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(require '[com.climate.claypoole \:as cp])" "(cp/pmap 4 (score (workingList)))" "(cp/pmap choice(workingList))" "(cp/pmap (choice(workingList)))" "(doall (cp/pmap (choice workingList)))" "(cp/pmap 4 (choice workingList))" "(cp/pmap 4 (choice (workingList)))" "(cp/pmap 4 (choice) (workingList))" "(cp/pmap 4 (workingList))" "(cp/pmap 4 (choice(workingList workingList)))" "(cp/pmap 4 choice(workingList))" "(def choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(def choice ([x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(choice (workingList))" "(cp/pmap choice workingList)" "(_" "(cp/pmap 4 (choice (workingList)))" "(cp/pmap 4 workingList)" "(cp/pmap 4 (choice workingList))" "(score (working List))" "(score (workingList))" "(splitter 4 (convertedList))" "(defn read-lines [filename]\\n  (let [rdr (reader filename)]\\n    (defn read-next-line []\\n      (if-let [line (.readLine rdr)]\\n       (cons line (lazy-seq (read-next-line)))\\n       (.close rdr)))\\n    (lazy-seq (read-next-line)))\\n)" "(read-lines\\n  )" "(read-lines \\"resources/10.txt\\")" "(splurp \\"resources/10.txt\\")" "(slurp \\"resources/10.txt\\")" "(choice (slurp \\"resources/10.txt\\"))" "(type (slurp \\"resources/10.txt\\"))" "(apply str-2-int (slurp \\"resources/10.txt\\"))" "(str-2-int (slurp \\"resources/10.txt\\"))" "(type (str-2-int (slurp \\"resources/10.txt\\")))" "(type (workingList))" "(type (convertedList))" "(type workingList)" "(type (rest (convertedList)))" "(choice (testa))" "(type choice)" "player1" "(choice (testa))" "(testa)" "testa" "(choice testa)" "(cp/pmap 4 (choice testa))" "(cp/pmap 2 choice testa)" "(def testa\\n(rest (str-2-int (slurp \\"resources/10.txt\\"))))" "(score testa)" "(def testa\\n(rest (str-2-int (slurp \\"resources/100.txt\\"))))" "(choice testa)" "(doc inc)" "(splitter 4 testa)" "(pmap choice (splitter 4 testa))" "(pmap choice (splitter 16 testa))" "(pmap choice (splitter 32 testa))" "(pmap choice (splitter 4 testa))" "(cp/pmap 4 choice testa)" "(cp/pmap 4 (splitter 2 (choice testa)))" "(cp/pmap 16 (choice (splitter 4 testa)))" "(cp/pmap 16 (splitter 4 (choice testa)))" "(pmap score(splitter 20 testa))" "(pmap choice(splitter 20 testa))" "(reduce + (pmap choice(splitter 4 testa)))" "(pmap choice(splitter 4 testa))" "(reduce + (pmap choice(splitter 4 testa)))" "(score (testa 4))" "(score testa 4)" "(def testa\\n(rest (str-2-int (slurp \\"resources/10.txt\\"))))" "(testa)" "testa" "(score testa 2)" "(score testa 1)" "(score testa 5)" "(splitter 2 testa)" "(score testa 2)" "(choice testa)" "(player1 (testa 2))" "(player1 testa 2)" "(partition 4 (range 20))" "(partition 4 (testa))" "(partition 4 testa)" "(partition 4 4 testa)" "(partition 4 nil testa)" "(partition 4 4 nil testa)" "(defn splitter [splitBy numbers]\\n\\t(partition (/ (count numbers) splitBy) (/ (count numbers) splitBy) nil numbers))" "(splitter 16 testa)" "(splitter 2 testa)" "(splitter 4 testa)" "(defn splitter [splitBy numbers]\\n\\t(partition splitBy splitBy nil numbers))" "(splitter 16 testa)" "(def testa\\n(rest (str-2-int (slurp \\"resources/100.txt\\"))))" "(score testa 16)" "(score testa 8)" "(score testa 4)" "(score testa 2)" "(score testa 1)" "(choice (splitter 4 testa))" "(pmap choice(splitter 4 testa))" "(reduce + (pmap choice(splitter 4 testa)))" "(reduce + (pmap choice(splitter  testa)))" "(reduce + (pmap choice(splitter 8 testa)))" "(reduce + (pmap choice(splitter 16 testa)))" "(reduce + (pmap choice(splitter 2 testa)))" "(reduce + (pmap choice(splitter 1 testa)))" "(reduce + (pmap choice(splitter 4 testa)))" "(reduce + (pmap choice(splitter 2 testa)))" "(reduce + (pmap choice(splitter 4 testa)))" "(reduce + (pmap choice(splitter 20 testa)))" "(reduce + (pmap choice(splitter 5 testa)))" "(pmap choice(splitter 16 testa))" "(pmap choice(splitter 5 testa))" "(choice (pmap choice(splitter 5 testa)))" "(choice (pmap choice(splitter 10 testa)))" "(choice (pmap choice(splitter 4 testa)))" "(reduce + (pmap choice(splitter 10 testa)))" "(splitter 10 testa)" "(reduce + (pmap choice(splitter 10 testa)))" "(reduce + (pmap choice(splitter 5 testa)))" "(choice testa)" "(score testa 1)" "(score testa 2)" "(score testa 3)" "(score testa 4)" "(score testa 5)" "(doall (score testa 3))" "(doall (score testa 2))" "(mainProg testa)" "(mainProg (testa))" "(mainAlg testa)" "(choice testa)" "(altChoice testa)" "mainProg" "(mainProg testa)" "(mainProg (workingList))" "(mainProg (convertedList))" "(def testa\\n(apply (rest (str-2-int (slurp \\"resources/10.txt\\")))))" "(apply (str-2-int (slurp \\"resources/10.txt\\")))" "(apply str-2-int (slurp \\"resources/10.txt\\"))" "(score (workingList))" "(type testa)" "(def testa\\n(rest (str-2-int (slurp \\"resources/10.txt\\"))))" "(type testa)" "(type convertedList)" "(mainProg testa)" "(mainProg (testa))" "(mainProg (splitter 4 testa))" "(mainProg (convertedList))" "(score testa 10)" "(score testa 2)" "(splitter 2 testa)" "(choice testa)" "(pmap choice(splitter 2 testa)\\n      )" "(+ 172 44)" "testa" "(splitter 4 testa)" "(splitter 5 testa)" "(pmap choice(splitter 5 testa)\\n      )" "(+ 95 83 37 94 11)" "(defn splitter [splitBy numbers]\\n\\t(partition splitBy numbers))" "(splitter 4 testa)" "(defn splitter [splitBy numbers]\\n\\t(partition splitBy splitBy numbers))" "(splitter 4 testa)" "(defn splitter [splitBy numbers]\\n\\t(partition splitBy splitBy [] numbers))" "(splitter 4 testa)" "(splitter 8 testa)" "(choice testa 8)" "(pmap choice( splitter 8 testa))" "(reduce +(pmap choice(splitter 8 testa)))" "(splitter 1 testa)" "(bb testa)" "(defn bb [x] \\n((juxt filter remove) 2 x))" "(bb testa)" "(separate 2 testa)" "(defn splitter [splitBy numbers]\\n\\t(partition-all splitBy numbers))" "(splitter 2 testa)" "(defn splitter [splitBy numbers]\\n\\t(partition-all (/ (count numbers) splitBy) numbers))" "(splitter 2 testa)" "(splitter 4 testa)" "(choice testa)" "(splitter 4 testa)" "(splitter 16 testa)" "(pmap choice (testa))" "(pmap choice( splitter 16 testa))" "(choice(pmap chocie(splitter 16 testa)))" "(choice (pmap choice(splitter 16 testa)))" "(choice (pmap choice(splitter 8 testa)))" "(splitter 8 testa)" "(choice(splitter 8 testa))" "(pmap choice(splitter 8 testa))" "(+ reduce(pmap choice(splitter 8 testa)))" "(reduce + (pmap choice(splitter 8 testa)))" "(splitter 8 testa)" "(reduce + (pmap choice(splitter 4 testa)))" "(splitter 4 testa)" "(reduce + (choice (pmap choice(splitter 4 testa))))" "(choice (pmap choice(splitter 4 testa)))" "(splitter 4 testa)" "(reduce +(pmap choice(splitter 4 testa)))" "(splitter 8 testa)" "(score workingList 4)" "(score workingList testa)" "(score testa 4)" "(score testa 2)" "(score testa 1)" "(splitter 1 testa)" "(splitter 2 testa)" "(splitter 3 testa)" "(splitter 4 testa)" "(def choice (fn [x]\\n  (cond\\n    (\= (mod x 2) 1) (splitter 2 x)\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(choice testa 2)" "(choice testa)" "(pmap choice(splitter 2 testa))" "(def choice (fn [x]\\n  (cond\\n    (\= (mod (count x) 2) 1) (splitter 2 x)\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(pmap choice(splitter 2 testa))" "(player1 testa 2)" "(choice testa)" "(pmap choice(splitter 2 testa))" "(pmap choice(splitter 4 testa))" "(pmap choice(pmap choice(splitter 4 testa)))" "(reduce + (pmap choice(splitter 4 testa)))" "(def choice (fn [x]\\n  (cond\\n    (\= (mod x 2) 1) (splitter 2 x)\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(choice testa)" "(def choice (fn [x]\\n  (cond\\n    (\= (mod (count x) 2) 1) (splitter 2 x)\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(choice testa)" "(time (choice testa))" "(pmap choice(splitter 2 testa))" "(def choice (fn [x]\\n  (cond\\n    (\= (mod (count x) 2) 1) (choice (splitter 2 x))\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(pmap choice(splitter 2 testa))" "(def a '(1 2 3))" "a" "(splitter 2 a)" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    (\= (count x) 3) (max (+ (first x) (min (first(rest x)), (last x))),\\n                         (+ (last x) (min (first x), (first(rest x)))))\\n    (\= (mod (count x) 2) 1) (choice (splitter 2 x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(choice testa)" "(pmap choice(splitter 2 testa))" "(splitter 2 testa)" "(splitter 3 testa)" "(choice testa)" "(pmap choice(splitter 2 testa))" "(choice(pmap choice(splitter 2 testa)))" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    (\= (count x) 3) (max (+ (first x) (min (first(rest x)), (last x))),\\n                         (+ (last x) (min (first x), (first(rest x)))))\\n    (\= (mod (count x) 2) 1) (reduce + (pmap choice (splitter 2 x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    (\= (count x) 3) (max (+ (first x) (min (first(rest x)), (last x))),\\n                         (+ (last x) (min (first x), (first(rest x)))))\\n    (\= (mod (count x) 2) 1) (reduce + (pmap choice (splitter 2 x)))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(pmap choice(splitter 2 testa))" "(pmap choice(splitter 3 testa))" "(reduce + (pmap choice(splitter 3 testa))\\n        )" "(splitter 2 testa)" "(splitter 3 testa)" "(reduce + (pmap choice(splitter 4 testa)))" "(splitter 4 testa)" "(def a '(1 2 3 4 5))" "a" "(splitter 2 a)" "(splitter 3 a)" "(splitter 4 a)" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    (\= (count x) 3) (max (+ (first x) (min (first(rest x)), (last x))),\\n                         (+ (last x) (min (first x), (first(rest x)))))\\n    (\= (mod (count x) 2) 1) (pmap choice (splitter 2 x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(choice testa)" "(player1 testa 2)" "(pmap choice(splitter 2 testa))" "(pmap choice(pmap choice(splitter 2 testa)))" "(reduce +(pmap choice(pmap choice(splitter 2 testa))))" "(reduce +(pmap choice(pmap choice(splitter 3 testa))))" "(reduce +(pmap choice(pmap choice(splitter 1\\n                                           testa))))" "(player1 testa 2)" "(player1 testa 1)" "(splitter 2 testa)" "(splitter 2(splitter 2 testa))" "(player1 testa 3)" "(player1 testa 5)" "(player1 testa 6)" "(player1 testa 8)" "(player1 testa 10)" "(player1 testa 16)" "(defn player1 [x threads]\\n  (cond\\n    (< threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy.\\")\\n  \:else (reduce + (pmap choice (splitter threads x)))))" "(player 1 testa 16)" "(player1 testa 16)" "(defn player1 [x threads]\\n  (cond\\n    (> threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy.\\")\\n  \:else (reduce + (pmap choice (splitter threads x)))))" "(player1 testa 16)" "(player1 testa 9)" "(player1 testa 10)" "(defn player1 [x threads]\\n  (cond\\n    (>\= threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy. try different threadCount\\")\\n  \:else (reduce + (pmap choice (splitter threads x)))))" "(player1 testa 10)" "(player1 testa 2)" "(player1 testa 1)" "(player1 testa 2)" "(player1 testa 3)" "(splitter 3 testa)" "(player1 testa 4)" "(splitter 4 testa)" "(player1 testa 1)" "(player1 testa 5)" "(player1 testa 7)" "(player1 testa 8)" "(splitter testa 8)" "(splitter 8 testa)" "(def a '(1 2 3 4 5 6 7))" "a" "(splitter 2 a)" "(\= (mod (count a) 2) 1)" "(splitter 3 a)" "(splitter 4 a)" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    (\= (count x) 3) (max (+ (first x) (min (first(rest x)), (last x))),\\n                         (+ (last x) (min (first x), (first(rest x)))))\\n    (\= (mod (count x) 2) 1) (pmap choice(splitter 4 x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(player1 testa 4)" "(choice testa)" "(player1 testa 5)" "(splitter 5 testa)" "(player1 testa 6)" "(player1 testa 5)" "(pmap choice(splitter 5 testa))" "(pmap choice(splitter 6 testa))" "(player1 testa 10)" "(player1 testa 20)" "(player1 testa 22)" "(player1 testa 24)" "(splitter testa 24)" "(splitter 24 testa)" "(player1 testa 15)" "(player1 testa 16)" "(player1 testa 17)" "(player1 testa 18)" "(player 1 testa 19)" "(player1 testa 19)" "(player1 testa 20)" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    (\= (mod (count x) 2) 1) (choice (pmap choice(splitter 4 x)))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(player1 testa 5)" "player1 testa 10" "(player1 testa 10)" "(player1 testa 20)" "(player1 testa 8)" "(player1 testa 10)" "(def choice (fn [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    (\= (mod (count x) 2) 1) (choice (pmap choice(splitter 2 x)))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))))" "(player1 testa 4)" "(player1 testa 8)" "(player1 testa 16)" "(player1 testa 32)" "(splitter testa 32)" "(splitter 32 testa)" "(player1 testa 1)" "(player1 testa 2)" "(splitter 2 testa)" "(pmap choice(splitter 2 testa))" "(player1 testa 2)" "(player1 testa 3)" "(splitter 3 testa)" "(splitter 4 testa)" "(player1 testa 4)" "(player1 testa 5)" "(splitter 5 testa)" "(splitter 6 testa)" "(splitter 7 testa)" "(splitter 8 testa)" "(splitter 2 testa)" "(player1 testa 2)" "(player1 testa 4)" "(player1 testa 8)" "(splitter 4 testa)" "(count (splitter 4 testa))" "(count (count (splitter 4 testa)))" "(defn splitter [splitBy numbers]\\n\\t(partition-all splitBy numbers))" "(splitter 2 testa)" "(splitter 4 testa)" "(player1 testa 2)" "(player1 testa 4)" "(player1 testa 8)" "(/ 100 8)" "(mod (/ 100 8) 2)" "(def testa\\n(rest (str-2-int (slurp \\"resources/100.txt\\"))))" "(player1 testa 4)" "(player1 testa 8)" "(splitter 8 testa)" "(player1 testa 4)" "(splitter 4 testa)" "(count (splitter 4 testa)\\n       )" "(count (splitter 5 testa))" "(count (splitter 6 testa))" "(counter (splitter 7 testa))" "(count (splitter 7 testa))" "(count (splitter 8 testa))" "(count (splitter 16 testa))" "(count (splitter 10 testa))" "(player1 10 testa)" "(player1 testa 10)" "(count (splitter 20 testa))" "(player1 testa 20)" "(count (splitter 22 testa))" "(count (splitter 26 testa))" "(player1 testa 26)" "(splitter 20 testa)" "(mainProg convertedList)" "(mainProg (convertedList))" "(pmap mainProg(splitter 2 convertedList))" "(pmap mainProg(splitter 2 (convertedList)))" "(mainProg (convertedList))" "(player1 testa 4)" "(mainProg (convertedList))" "(pmap mainProg (splitter 4 testa))" "(pmap mainProg (splitter 10 testa))" "(mainProg (convertedList))" "(cp/pmap 4 (mainProg (convertedList)))" "(cp/pmap 4 choice(testa))" "(cp/pmap 4 choice(splitter 2 testa))" "(reduce + (cp/pmap 4 choice(splitter 4 testa)))" "(cp/pmap 4 choice testa)" "(cp/pmap 4 choice(splitter 1 testa))" "(cp/pmap 8 choice(splitter 1 testa))" "(cp/pmap 8 choiceb(splitter 1 testa))" "(cp/pmap 4 choiceb testa)" "(cp/pmap 4 choiceb (splitter 1 testa))" "(splitter 2 testa)" "(def testa\\n(rest (str-2-int (slurp \\"resources/10.txt\\"))))" "(splitter 2 testa)" "(splitter 4 testa)" "(splitter 6 testa)" "(splitter 10 testa)" "(pmap choiceb(splitter 10 testa)\\n      )" "(splitter 16 testa)" "(def a '(1 2 3 4 5))" "a" "(rest (butlast a))" "(rest(rest a))" "(butlast(butlast a))" "(rest( butlast x))" "(rest(butlast a))" "(score testa 4)" "(score testa 8)" "(score testa 16)" "(score testa 32)" "(score testa 20)" "(score testa 10)" "(defn player1 [x threads]\\n  (cond\\n    (>\= threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy. try different threadCount\\")\\n  \:else (reduce + (pmap choice (splitit (splitter threads x))))))" "\\n(defn score [x threads]\\n  (let [player1 (player1 x threads)]\\n  (println \\"Player 1 will receive\\" player1 \\"Player 2 gets\\" (- (reduce + x) player1))))\\n\\n(println \\" Enter file you wish to read from in 'file.txt' format from Resources. \\")  \\n;;(score (workingList))" "(player1 testa 8)" "(player1 testa 4)" "(player1 testa 10)" "(player1 testa 8)" "(player1 testa 10)" "(player1 testa 4)" "(player1 testa 2)" "(player1 convertedList 4)" "(player1 testa 8)" "(player1 testa 16)" "(player1 testa 32)" "(defn player1 [x threads]\\n  (cond\\n    (>\= threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy. try different threadCount\\")\\n  \:else (pmap choice (splitter threads x))))" "(player1 testa 32)" "(player1 testa 4)" "(player1 testa 8)" "\\n(defn player1 [x threads]\\n  (cond\\n    (>\= threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy. try different threadCount\\")\\n  \:else (doall (pmap choice (splitter threads x)))))" "(player1 testa 4)" "(defn player1 [x threads]\\n  (cond\\n    (>\= threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy. try different threadCount\\")\\n  \:else (doall (map choice (splitter threads x)))))" "(player1 testa 8)" "(player1 testa 4)" "(player1 testa 5)" "(score (workingList))" "\\n(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(score (workingList))" "(score (workingList) 4)" "(defn score [x threads]\\n  (let [player1 (player1 x threads)]\\n  (println \\"Player 1 will receive\\" player1 \\"Player 2 gets\\" )))" "(score (workingList) 4)" "\\n(defn player1 [x threads]\\n  (cond\\n    (>\= threads (count x)) (println \\"ThreadCount higher than list size, algorithm will perform greedy. try different threadCount\\")\\n  \:else (reduce + (doall (pmap choice (splitter threads x))))))" "(score (workingList) 4)" "(score (workingList) 2)" "(score (workingList) 1)" "(defn threadingProg [x]\\n  (score x threads))" "(defn threadingProg [x threads]\\n  (score x threads))" "(defn threadingProg [x]\\n  (println \\"First single Thread\\" (time (score x 1)))\\n  (println \\"Two Threads\\" (time (score x 2)))\\n  (println \\"Four Threads\\" (time (score x 4))))" "(threadingProg (workingList))" "(defn getOptimalScore [vec]\\n  (if(\= (count vec)2)\\n    ; return max of the final two choices\\n    (max (first vec) (last vec))\\n    ; else recurse with new list\\n    (max\\n      (+ (first vec)\\n         (min\\n           (getOptimalScore (drop 1 (drop-last 1 vec)))\\n           (getOptimalScore (drop 2 vec))))\\n      (+ (last vec)\\n         (min\\n           (getOptimalScore (drop-last 2 vec))\\n           (getOptimalScore (drop 1 (drop-last 1 vec))))))))" "(getOptimalScore (workingList))" "(reduce + (doall(pmap getOptimalScore(splitter 2 (workingList)))))" "(reduce + (doall(pmap getOptimalScore(splitter 4 (workingList)))))" "(reduce + (doall(pmap getOptimalScore(splitter 2 workingList))))" "(getOptimalScore (splitter 2 workingList))" "(pmap getOptimalScore(splitter 2 workingList))" "(getOptimalScore (workingList))" "(pmap getOptimalScore(splitter 2 workingList))" "(pmap getOptimalScore (splitter 4 convertedList))" "(pmap choice(splitter 2 workingList))" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 3) (max (first x), (last x))\\n    \:else (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(threadingProg (workingList))" "(def a '(1 2 3 4 5))" "a" "(defn b [a] (max (+ (first x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (last x) (min (choice (butlast( butlast x))), (choice(rest (butlast x)))))))" "a" "(choice a)" "(defn choice [x]\\n  (cond\\n    (<\= (count x) 2) (max (first x), (last x))\\n    \:else (max (+ (last x) (min (choice (rest (butlast x))),  (choice(rest(rest x))))),\\n               (+ (first x) (min (choice (butlast( butlast x))), (choice(rest (butlast x))))))))" "(choice a)" "(choice workingList)" "(choice (workingList))" "(threadingProg (workingList))" "(def a '(1 2 1 2 1))" "(def a '(1 1 1 1 1))" "(choice a)" "(def a '((1 1 1) (1 1)))" "a" "(pmap choice(a))" "(pmap choice a)" "(def a '((1 1 1)(1 1 1)(1 1)))" "a" "(pmap choice a)" "(choice (workingList)\\n        )" "(pmap choice(splitter 2 workingList))" "(pmap choice(splitter 2 (workingList)))" "(+ 172 44)" "(splitter 2 (workingList))" "(def a '((95 71 83 6 37) (35 94 1 11 8)))" "a" "(choice a)" "(pmap choice a)" "(map choice a)" "(def b '(95 71 83 6 37))" "b" "(choice b)" "(def c '(35 94 1 11 8))" "c" "(choice c)" "a" "(def a (workingList))" "a" "(choice a)" "(choice b)" "choice c" "(choice c)" "(def b '((95 71 83 6 37 35)(94 1 11 8)))" "b" "(choice b)" "(pmap choice b)" "(reduce +(pmap choice b))" "(defn int-partition [num size]\\n   (let [f (int (Math/pow 10 size))]\\n      (loop [n num l ()]\\n         (if (zero? n) \\n            (vec l) \\n            (recur (int (/ n f)) (conj l (mod n f)))))))\\n\\n(defn split-nums [nums factor] (vec (map \#(int-partition % factor) nums)))" "(split-nums (workingList) 2)" "(split-nums workingList 2)" "(split-nums workingList 4)" "(split-nums (workingList 4))" "(split-nums (workingList) 4)" "(defn trunc-to-even\\n  \\"Truncates a value the largest int less than or equal to value\\"\\n  [val]\\n  (* 2 (Math/floor (/ val 2))))\\n\\n(defn splitA [x threads]\\n  (let [half-even (trunc-to-even (/ (count x) threads))]\\n    (split-at half-even x )))" "(splitA (workingList))" "(splitA (workingList) 2)" "(splitA (workingList) 4)" "(splitA (workingList) 8)" "\\n(defn trunc-to-even\\n  \\"Truncates a value the largest int less than or equal to value\\"\\n  [val]\\n  (* 2 (Math/floor (/ val 2))))\\n\\n(defn even-lists [some-list]\\n  (let [half-even (trunc-to-even (/ (count some-list) 2))]\\n    (split-at half-even some-list )))" "(even-lists (workingList))" "(split-4 (workingList))" "(even-lists (workingList))" "(even-lists (even-lists(workingList)))" "(defn split-4 [x]\\n  (pmap even-lists(even-lists (x))))" "(split-4 (workingList))" "(defn split-4 [x]\\n  (even-lists(even-lists (x))))" "(split-4 (workingList))" "(split-4 (workingList)\\n         )" "(defn split-4 [x]\\n  (map even-lists(even-lists (x))))" "(split-4 (workingList))" "(even-lists (workingList))" "(type (even-lists (workingList)))" "(defn split-4 [x]\\n  (map even-lists(seq even-lists (x))))" "(split-4 (workingList))" "(pmap even-lists(even-lists(workingList)))" "(split-4 (workingList))" "(pmap choice (split-4 workingList))" "(pmap choice(split-4(workingList)))" "(split-4(workingList))" "(choice(split-4(workingList)))" "(concat (split-4(workingList)))" "(into () (concat (split-4(workingList))))" "(pmap choice(even-lists(workingList)))" "(+ 178 142)" "(even-lists(workingList))" "(defn split-4 [x]\\n  (pmap even-lists(concat (even-lists x))))" "(split-4 (workingList))" "(apply concat(split-4(workingList)))" "(defn split-4 [x]\\n  (apply concat (pmap even-lists(concat (even-lists x)))))" "(split-4 (workingList))" "(defn trunc-to-even\\n  \\"Truncates a value the largest int less than or equal to value\\"\\n  [val]\\n  (* 2 (Math/floor (/ val 2))))\\n\\n(defn split-2 [some-list]\\n  (let [half-even (trunc-to-even (/ (count some-list) 2))]\\n    (split-at half-even some-list )))\\n\\n(defn split-4 [x]\\n  (apply concat (pmap split-2(concat (split-2 x)))))" "(pmap choice(split-4 (workingList)))" "(reduce +(pmap choice(split -4(workingList))))" "(reduce +(pmap choice(split-4(workingList))))" "(defn split-8 [x]\\n  (apply concat (pmap split-4(concat (split-4 x)))))" "(split-8 (workingList))" "(defn split-8 [x]\\n  (apply concat (pmap split-4(concat (split-2 x)))))" "(split-8 (workingList))" "(reduce +(pmap choice(split-2 workingList)))" "(reduce +(pmap choice(split-2 (workingList))))" "(split-16 (workingList))" "(pmap choice(split-16 (workingList)))" "(reduce + (pmap choice(split-16(workingList))))" "(reduce + (pmap choice(split-8(workingList))))" "(reduce +(map choice(split-16(workingList))))" "(reduce+(map choice(split-8(workingList))))" "(reduce + (map choice(split-8 (workingList))))" "(split-32 (workingList))" "(def a '(95 12 30 54))" "(choice a)" "(defn getOptimalScore [vec]\\n  (if(\= (count vec)2)\\n    ; return max of the final two choices\\n    (max (first vec) (last vec))\\n    ; else recurse with new list\\n    (max\\n      (+ (first vec)\\n         (min\\n           (getOptimalScore (drop 1 (drop-last 1 vec)))\\n           (getOptimalScore (drop 2 vec))))\\n      (+ (last vec)\\n         (min\\n           (getOptimalScore (drop-last 2 vec))\\n           (getOptimalScore (drop 1 (drop-last 1 vec))))))))" "(getOptimalScore a)" "(reduce +(pmap getOptimalScore(split-32 x)))" "(reduce +(pmap choice(split-32 (workingList))))" "(reduce +(pmap choice(split-16 (workingList))))" "(split-16 (workingList))" "(pmap choice(split-4 (workingList)))" "(pmap choice(split-8 (workingList)))" "(split-8 (workingList))" "(defn split-8 [x]\\n  (apply concat (pmap split-4(concat (split-4 x)))))" "(split-8 (workingList)" "(split-8 (workingList))" "(score32 (workingList))" "(score16 (workingList))" "(score8 (workingList))" "(score4 (workingList))" "(defn split-2 [some-list]\\n  (let [half-even (trunc-to-even (/ (count some-list) 2))]\\n    (split-at half-even some-list )))\\n(defn split-4 [x]\\n  (apply concat (pmap split-2(concat (split-2 x)))))\\n(defn split-8 [x]\\n  (apply concat (pmap split-4(concat (split-2 x)))))\\n(defn split-16 [x]\\n  (apply concat (pmap split-8(concat (split-2 x)))))\\n(defn split-32 [x]\\n  (apply concat (pmap split-16(concat (split-2 x)))))" "(split-4 (workingList))" "(defn split-4 [x]\\n  (apply concat (pmap split-2(split-2 x))))" "(split-4 (workingList))" "(defn split-2 [some-list]\\n  (let [half-even (trunc-to-even (/ (count some-list) 2))]\\n    (split-at half-even some-list )))\\n(defn split-4 [x]\\n  (apply concat (pmap split-2(split-2 x))))\\n(defn split-8 [x]\\n  (apply concat (pmap split-4(split-2 x))))\\n(defn split-16 [x]\\n  (apply concat (pmap split-8(split-2 x))))\\n(defn split-32 [x]\\n  (apply concat (pmap split-16(split-2 x))))" "(score4 (workingList))" "(score8 (workingList))" "(try4 (workingList))" "(try8 (workingList))" "(pvalues choice(split-2 (workingList)))" "(pvalues (choice(split-2 (workingList))))" "(pvalues choice split-2 (workingList))" "(pcalls (choice (split-2 (workingList))))" "(pmap choice(split-2 (workingList)))" "(pmap choice(split-4 (workingList)))" "(+ 95 83 37 105)" "(+172 142)" "(+ 172 142)" "(+ 98 83)" "(+ 83 105)" "(pmap choice(split-8 (workingList)))" "(split-8 (workingList))" "(split-32(workingList))" "(split-4 (workingList))" "(split-8 (workingList))" "(defn split-2 [x]\\n  (let [half-even (trunc-to-even (/ (count x) 2))]\\n    (split-at half-even x )))\\n(defn split-4 [x]\\n  (apply concat (pmap split-2(split-2 x))))\\n(defn split-8 [x]\\n  (apply concat (pmap split-2(split-4 x))))\\n(defn split-16 [x]\\n  (apply concat (pmap split-2(split-8 x))))\\n(defn split-32 [x]\\n  (apply concat (pmap split-2(split-16 x))))" "(split-4 (workingList))" "(score8 (workingList))" "(score16 (workingList))" "(defn get-lines [file]\\n  (str/split-lines (slurp file)))" "(get-lines \\"resources/10.txt\\")" "(defn get-lines [file]\\r\\n  (map read-string \\r\\n       (str/split-lines\\r\\n         (slurp file)\\r\\n         )\\r\\n       )\\r\\n  )" "(get-lines \\"resources/10.txt\\")"]
eclipse.preferences.version=1
